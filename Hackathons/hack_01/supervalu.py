from openai import OpenAI
import streamlit as st
from transformers import DetrImageProcessor, DetrForObjectDetection
import torch
from PIL import Image
import pandas as pd
import ast
import re
import datetime

st.set_page_config(page_title="SuperValu-ShopBot", page_icon=":robot_face:", layout="centered")

st.title(":robot_face: SuperValu-ShopBot :robot_face:")
st.markdown('''*:rainbow[Welcome to SuperValu-ShopBot! This is a conversational AI assistant that can generate recipes based on the items in your shopping cart or the image of your refrigerator. Simply upload an image or type in the items you have, and the assistant will provide you with a recipe suggestion.]*''')

OpenAI.api_key = st.secrets["OPENAI_API_KEY"]  
client = OpenAI()


if "openai_model" not in st.session_state:
    st.session_state["openai_model"] = "gpt-4o"

if "messages" not in st.session_state:
    st.session_state.messages = []
    
if 'add_missing_clicked' not in st.session_state:
    st.session_state.add_missing_clicked = False

if 'check_out_clicked' not in st.session_state:
    st.session_state.check_out_clicked = False
    
if "cart_list" not in st.session_state:
        st.session_state.cart_list = []

if "missing_items" not in st.session_state:
        st.session_state.missing_items = []
               
if "cart_table" not in st.session_state:
    st.session_state.cart_table = None

if "delivery_date" not in st.session_state:
    st.session_state.delivery_date = None
        
for message in st.session_state.messages:
    role = message["role"]
    content = message["content"]
    if role != "system" and st.session_state.check_out_clicked != True:
        with st.chat_message(role):
            st.markdown(content)

    
def detect_objects(uploaded_file):
    image = Image.open(uploaded_file)

    # you can specify the revision tag if you don't want the timm dependency
    processor = DetrImageProcessor.from_pretrained("facebook/detr-resnet-101", revision="no_timm")
    model = DetrForObjectDetection.from_pretrained("facebook/detr-resnet-101", revision="no_timm")

    inputs = processor(images=image, return_tensors="pt")
    outputs = model(**inputs)

    # convert outputs (bounding boxes and class logits) to COCO API
    # let's only keep detections with score > 0.7  # Adjusted threshold value to 0.7
    target_sizes = torch.tensor([image.size[::-1]])
    results = processor.post_process_object_detection(outputs, target_sizes=target_sizes, threshold=0.7)[0]

    detected_objects = []
    for score, label, box in zip(results["scores"], results["labels"], results["boxes"]):
        detected_objects.append(model.config.id2label[label.item()])
    # st.write(f"Detected Objects: {detected_objects}")
    return list(set(detected_objects))

def get_missing_items(response, cart_list):
    edible_items = client.completions.create(
        model="gpt-3.5-turbo-instruct-0914",
        prompt=f"Presented herein is a response generated by the advanced GPT-4o model, encapsulating ```{response}```. Could you kindly endeavor to meticulously construct a python list in a format like ['rice', 'chicken'] comprising exclusively edible items derived from the amalgamation of ingredients articulated within the aforementioned response? I would appreciate abstaining from appending any extraneous characters, senetences, square brackets, numbers or symbols, dots, confining the output solely to the enumeration of consumable elements",
        temperature=0.6,
        max_tokens=256,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0
    )
    edible_items = edible_items.choices[0].text
    # st.write(edible_items)
    pattern = r"['\[\]]"
    edible_items = re.sub(pattern, '', edible_items)
    edible_items = list(edible_items.strip().split(','))
    for x in edible_items:
        if x not in cart_list:
            st.session_state.missing_items.append(x)
    # st.write(st.session_state.missing_items)
    # return st.session_state.missing_items

# def add_items(cart_list, missing_items, cart_table):
#     st.session_state.cart_list.extend(missing_items)
#     cart_table.add_rows(data=missing_items)
#     st.write(st.session_state.cart_list)     
     
def generate_recipe(prompt):
    st.session_state.messages.append({"role": "system", "content": "As a seasoned culinary expert, my primary objective is to furnish recipe suggestions based on the provided prompts from users. Additionally, in instances where users inquire for further recommendations, such as by requesting 'any other suggestions' or 'another one please,' I am committed to delivering recipe ideas derived from the initial prompt. Furthermore, I remain attentive to all pertinent instructions outlined by users, including but not limited to:- Facilitating users in charting their meal plans for the week and subsequently populating a shopping cart with all requisite ingredients.- Tailoring meal plans to accommodate users' unique circumstances, such as those pertaining to family size, like a family of five.- Catering to users' shopping preferences across various dimensions, encompassing factors like budgetary constraints (low/medium/high), dietary restrictions (e.g., lactose intolerance, celiac disease), and health objectives (e.g., weight loss). The shop bot algorithm diligently incorporates this information to curate personalized meal plans.It is imperative to note that any queries beyond the scope of recipe suggestions and meal planning guidance will not be entertained. In such instances, a polite declination message will be provided to redirect the user's focus back to the intended purpose."})
            
    st.session_state.messages.append({"role": "user", "content": prompt})

    # To show what user has typed           
    with st.chat_message("user"):
        st.markdown(prompt)

    # To show the reponse generated from GPT-3
    with st.chat_message("assistant"):
        stream = client.chat.completions.create(
            model=st.session_state["openai_model"],
            messages=[
                {"role": m["role"], "content": m["content"]}
                for m in st.session_state.messages
            ],
            stream=True,
        )
        response = st.write_stream(stream)
        get_missing_items(response,st.session_state.cart_list)
        
        # add_items(st.session_state.cart_list, missing_items, cart_table)
    st.session_state.messages.append({"role": "assistant", "content": response})

col1, col2, col3, col4 = st.columns(4)

def main(cart_list):    
    with col1:
        dietry_preference = st.multiselect("Dietary Preferences", ['Vegetarian', 'Gluten-free', 'Low-carb', 'Low-fat','Non-Vegetarian'])
    with col2:
        couisine_preference = st.selectbox("Couisine Preferences", ['Irish','Indian', 'Italian', 'Mexican', 'American'])
    with col3:
        flavor_preference = st.selectbox("Flavor Preferences", ['Spicy', 'Sweet', 'Sour', 'Bitter', 'Salty'])
    with col4:
        allergies_if_any = st.multiselect("Allergies", ['Peanuts', 'Dairy', 'Soy', 'Egg', 'Shellfish', 'Tree nuts', 'Wheat'])

    if cart_list:
        calculate_calories = st.checkbox("Calculate Calories")
        if st.button("Generate Recipe from Cart Items"):
            if (dietry_preference or couisine_preference or flavor_preference or allergies_if_any):
                if(calculate_calories):
                    generate_recipe(f"Create a recipe from the edible items from the list:{cart_list} with dietary preference:{dietry_preference}, couisine preference: {couisine_preference}, flavor preference: {flavor_preference}, allergies: {allergies_if_any} and calculate calories for each ingredient.")
                else:
                    generate_recipe(f"Create a recipe from the edible items from the list:{cart_list} with dietary preference:{dietry_preference}, couisine preference: {couisine_preference}, flavor preference: {flavor_preference}, allergies: {allergies_if_any}")                
            else:
                generate_recipe(f"Create a recipe from the edible items from the list:{cart_list}")
    if uploaded_file:
        if st.button("Generate Recipe from Image"):
            detected_objects = detect_objects(uploaded_file)
            if (dietry_preference or couisine_preference or flavor_preference or allergies_if_any and calculate_calories ):
                generate_recipe(f"Create a recipe from the edible items from the list:{detected_objects} with dietary preference:{dietry_preference}, couisine preference: {couisine_preference}, flavor preference: {flavor_preference}, allergies: {allergies_if_any} and calculate calories for each ingredient.")
            elif (dietry_preference or couisine_preference or flavor_preference or allergies_if_any):
                generate_recipe(f"Create a recipe from the edible items from the list:{detected_objects} with dietary preference:{dietry_preference}, couisine preference: {couisine_preference}, flavor preference: {flavor_preference}, allergies: {allergies_if_any}")
            else:
                generate_recipe(f"Create a recipe from the edible items from the list:{detected_objects}")
    if prompt := st.chat_input("What's the receipe you want?"):
            generate_recipe(prompt)
    
    if len(st.session_state.missing_items) != 0:
        st.button("Add Missing Items to Cart", on_click= lambda: st.session_state.update(add_missing_clicked=True))
        if (st.session_state.add_missing_clicked):
            st.session_state.cart_list.extend(st.session_state.missing_items) 
            # st.write(st.session_state.cart_list)
            cart_df = pd.DataFrame(st.session_state.cart_list, columns=['Items in Cart']) 
            cart_table.add_rows(data=st.session_state.missing_items)     
    
# hide_st_style = """
#             <style>
#             #MainMenu {visibility: hidden;}
#             footer {visibility: hidden;}
#             header {visibility: hidden;}
#             </style>
#             """
# st.markdown(hide_st_style, unsafe_allow_html=True)        


if __name__ == "__main__":
    
    # cart_list = ['milk', 'jaggery', 'apples', 'oats','rice', 'chicken', 'almonds', 'sunflower oil']
    # cart_list = ['white balsamic vinegar', 'salt', 'black pepper', 'chicken breasts', 'flour', 'butter', 'Irish whiskey', 'olive oil','chives', 'chicken stock', 'heavy cream']
    main_content = st.empty() 
    file_uploader_placeholder = st.empty()
    uploaded_file = file_uploader_placeholder.file_uploader("Choose a Image from your regrigerator", type=["jpg", "jpeg", "png"])
    
    st.session_state.cart_list = ['white balsamic vinegar', 'salt', 'black pepper', 'chicken breasts', 'flour', 'butter', 'Irish whiskey', 'olive oil','chives', 'chicken stock', 'heavy cream']
    cart_df = pd.DataFrame(st.session_state.cart_list, columns=['Items in Cart'])
    cart_table = st.sidebar.table(data=cart_df) 
               
    st.sidebar.button("Proceed for checkout", on_click= lambda: st.session_state.update(check_out_clicked=True))
    if st.session_state.check_out_clicked:
        st.session_state.cart_list = []  
        st.session_state.messages = []
        cart_df = pd.DataFrame(st.session_state.cart_list, columns=['Items in Cart']) 
        cart_table.table(data=cart_df)  
        file_uploader_placeholder.empty()
        main_content = st.empty()
        
        st.session_state.delivery_date =  st.sidebar.date_input("Select Delivery Date", datetime.date.today())
        if st.session_state.delivery_date:
            main_content.subheader(f"Thank you! Your items will be delivered by {st.session_state.delivery_date}.")
        else:
            main_content.subheader(f"Thank you! Your items will be delivered soon.") 
      
    
    if st.session_state.cart_list:
        main_content = main(st.session_state.cart_list) 
