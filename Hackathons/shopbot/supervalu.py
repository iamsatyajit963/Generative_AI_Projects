from openai import OpenAI
import streamlit as st
from transformers import DetrImageProcessor, DetrForObjectDetection
import torch
from PIL import Image
import pandas as pd
import ast
import re
from pymongo import MongoClient
from datetime import datetime, time, timedelta,date
from pytz import timezone
import random
import string

st.set_page_config(page_title="ShopBot", page_icon=":robot_face:", layout="centered")
col1, col2 = st.columns([1, 3])
col1.image(r'C:\Users\satyajit.senapati\OneDrive - Infosys Limited\Documents\@Infy\infy_repo\personal_learning\streamlit\SperValuLogo.png',width=150)
col2.title(":robot_face: -ShopBot :robot_face:")
# st.title(":robot_face: ShopBot :robot_face:")
st.markdown('''*:rainbow[Welcome to ShopBot! This is a conversational AI assistant that can generate recipes based on the items in your shopping cart or the image of your refrigerator. Simply upload an image or type in the items you have, and the assistant will provide you with a recipe suggestion.]*''')

OpenAI.api_key = st.secrets["OPENAI_API_KEY"]  
client = OpenAI()
tz = timezone('America/New_York')
def generate_order_id(length=20):
    characters = string.ascii_uppercase + string.digits
    order_id = ''.join(random.choice(characters) for _ in range(length))
    return order_id

if "openai_model" not in st.session_state:
    st.session_state["openai_model"] = "gpt-4o"

if "messages" not in st.session_state:
    st.session_state.messages = []

if "order_id" not in st.session_state:
    st.session_state.order_id = 'SV-ORDER-ID-' + generate_order_id()
    
if "cust_id" not in st.session_state:
    st.session_state.cust_id = 'CUST-001' 
    
if 'add_missing_clicked' not in st.session_state:
    st.session_state.add_missing_clicked = False

if 'check_out_clicked' not in st.session_state:
    st.session_state.check_out_clicked = False

if 'add_recommended_clicked' not in st.session_state:
    st.session_state.add_recommended_clicked = False

if 'submit' not in st.session_state:
    st.session_state.submit_clicked = False   
    
if "cart_list" not in st.session_state:
        st.session_state.cart_list = []

if "missing_items" not in st.session_state:
        st.session_state.missing_items = []

if "recommended_items" not in st.session_state:
        st.session_state.recommended_items = []
                      
if "cart_table" not in st.session_state:
    st.session_state.cart_table = None

if "delivery_date" not in st.session_state:
    st.session_state.delivery_date = None

if 'submit' not in st.session_state:
    st.session_state.submit = False
        
for message in st.session_state.messages:
    role = message["role"]
    content = message["content"]
    if role != "system" and st.session_state.check_out_clicked != True:
        with st.chat_message(role):
            st.markdown(content)


def insert_detail(cust_id, order_id, cart_items):
    mongo_url = "mongodb+srv://hackathonuser:IOnIzBj0xjOW6rLn@cmsomcluster.hebweso.mongodb.net/?retryWrites=true&w=majority&appName=CMSOMCLUSTER"
    client = MongoClient(mongo_url)
    current_run_time=datetime.strptime(datetime.now(tz).strftime('%Y-%m-%dT%H:%M:%S'),'%Y-%m-%dT%H:%M:%S')
    data = {"cust_id" : cust_id,
            "order_id" : order_id,
            "cart_items" : cart_items,
            "timestamp" : current_run_time }
    collection = client["hackdb"]["botcollection"]
    collection.insert_one(data)
   
def detect_objects(uploaded_file):
    image = Image.open(uploaded_file)

    # you can specify the revision tag if you don't want the timm dependency
    processor = DetrImageProcessor.from_pretrained("facebook/detr-resnet-101", revision="no_timm")
    model = DetrForObjectDetection.from_pretrained("facebook/detr-resnet-101", revision="no_timm")

    inputs = processor(images=image, return_tensors="pt")
    outputs = model(**inputs)

    # convert outputs (bounding boxes and class logits) to COCO API
    # let's only keep detections with score > 0.7  # Adjusted threshold value to 0.7
    target_sizes = torch.tensor([image.size[::-1]])
    results = processor.post_process_object_detection(outputs, target_sizes=target_sizes, threshold=0.7)[0]

    detected_objects = []
    for score, label, box in zip(results["scores"], results["labels"], results["boxes"]):
        detected_objects.append(model.config.id2label[label.item()])
    # st.write(f"Detected Objects: {detected_objects}")
    return list(set(detected_objects))

def get_missing_items(response, cart_list):
    edible_items = client.completions.create(
        model="gpt-3.5-turbo-instruct-0914",
        prompt=f"Presented herein is a response generated by the advanced GPT-4o model, encapsulating ```{response}```. Could you kindly endeavor to meticulously construct a python list in a format like ['rice', 'chicken'] comprising exclusively edible items derived from the amalgamation of ingredients articulated within the aforementioned response? I would appreciate abstaining from appending any extraneous characters, senetences, square brackets, numbers or symbols, dots, confining the output solely to the enumeration of consumable elements. Ensure the output includes only consumable elements, without any extraneous characters, sentences, brackets, numbers, symbols, or non-edible terms.",
        temperature=0.6,
        max_tokens=256,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0
    )
    edible_items = edible_items.choices[0].text
    # st.write(edible_items)
    pattern = r"['\[\]]"
    edible_items = re.sub(pattern, '', edible_items)
    edible_items = list(edible_items.strip().split(','))
    for x in edible_items:
        if x not in cart_list:
            st.session_state.missing_items.append(x)
    # st.session_state.missing_items = list(set(st.session_state.missing_items)) # remove duplicates       
    # st.write(st.session_state.missing_items)
    # return st.session_state.missing_items

def generate_recipe(prompt):
    st.session_state.messages.append({"role": "system", "content": "As a seasoned culinary expert, my primary objective is to furnish recipe suggestions based on the provided prompts from users. Additionally, in instances where users inquire for further recommendations, such as by requesting 'any other suggestions' or 'another one please,' I am committed to delivering recipe ideas derived from the initial prompt. Furthermore, I remain attentive to all pertinent instructions outlined by users, including but not limited to:- Facilitating users in charting their meal plans for the week and subsequently populating a shopping cart with all requisite ingredients.- Tailoring meal plans to accommodate users' unique circumstances, such as those pertaining to family size, like a family of five.- Catering to users' shopping preferences across various dimensions, encompassing factors like budgetary constraints (low/medium/high), dietary restrictions (e.g., lactose intolerance, celiac disease), and health objectives (e.g., weight loss). The shop bot algorithm diligently incorporates this information to curate personalized meal plans in a tabular manner as much as possible for readability.It is imperative to note that any queries beyond the scope of recipe suggestions and meal planning guidance will not be entertained. In such instances, a polite declination message will be provided to redirect the user's focus back to the intended purpose."})
            
    st.session_state.messages.append({"role": "user", "content": prompt})

    # To show what user has typed           
    with st.chat_message("user"):
        st.markdown(prompt)

    # To show the reponse generated from GPT-3
    with st.chat_message("assistant"):
        stream = client.chat.completions.create(
            model=st.session_state["openai_model"],
            messages=[
                {"role": m["role"], "content": m["content"]}
                for m in st.session_state.messages
            ],
            stream=True,
        )
        response = st.write_stream(stream)
        get_missing_items(response,st.session_state.cart_list)
    st.session_state.messages.append({"role": "assistant", "content": response})

def generate_recommend_items(cart_items):
    recommend_items = client.completions.create(
        model="gpt-3.5-turbo-instruct-0914",
        prompt=f"Based on the items in my online shopping cart - {cart_items}, please provide 2-3 additional items in a Python list format. For example, if there is bread, you can recommend milk or jam in the format [milk, jam]. No additional comments or explanations are needed, just the list.",
        temperature=0.6,
        max_tokens=256,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0
    )
    st.write(f"Recommended Items:-> {recommend_items.choices[0].text}. Would you like to add them to the cart?")
    pattern = r"['\[\]]"
    recommend_items = re.sub(pattern, '', recommend_items.choices[0].text)
    recommend_items = list(recommend_items.strip().split(','))
    for x in recommend_items:
        if x not in cart_items:
            st.session_state.recommended_items.append(x)
    
col1, col2, col3, col4 = st.columns(4)

def main(cart_list):    
    with col1:
        dietry_preference = st.multiselect("Dietary Preferences", ['Vegetarian', 'Gluten-free', 'Low-carb', 'Low-fat','Non-Vegetarian'])
    with col2:
        couisine_preference = st.selectbox("Couisine Preferences", ['Irish','Indian', 'Italian', 'Mexican', 'American'])
    with col3:
        flavor_preference = st.selectbox("Flavor Preferences", ['Spicy', 'Sweet', 'Sour', 'Bitter', 'Salty'])
    with col4:
        allergies_if_any = st.multiselect("Allergies", ['Peanuts', 'Dairy', 'Soy', 'Egg', 'Shellfish', 'Tree nuts', 'Wheat'])

    if cart_list:
        calculate_calories = st.checkbox("Calculate Calories")
        if st.button("Generate Recipe from Cart Items"):
            if (dietry_preference or couisine_preference or flavor_preference or allergies_if_any):
                if(calculate_calories):
                    generate_recipe(f"Create a recipe from the edible items from the list:{cart_list} with dietary preference:{dietry_preference}, couisine preference: {couisine_preference}, flavor preference: {flavor_preference}, allergies: {allergies_if_any} and calculate calories for each ingredient.")
                else:
                    generate_recipe(f"Create a recipe from the edible items from the list:{cart_list} with dietary preference:{dietry_preference}, couisine preference: {couisine_preference}, flavor preference: {flavor_preference}, allergies: {allergies_if_any}")                
            else:
                generate_recipe(f"Create a recipe from the edible items from the list:{cart_list}")
    if uploaded_file:
        if st.button("Generate Recipe from Image"):
            detected_objects = detect_objects(uploaded_file)
            if (dietry_preference or couisine_preference or flavor_preference or allergies_if_any and calculate_calories ):
                generate_recipe(f"Create a recipe from the edible items from the list:{detected_objects} with dietary preference:{dietry_preference}, couisine preference: {couisine_preference}, flavor preference: {flavor_preference}, allergies: {allergies_if_any} and calculate calories for each ingredient.")
            elif (dietry_preference or couisine_preference or flavor_preference or allergies_if_any):
                generate_recipe(f"Create a recipe from the edible items from the list:{detected_objects} with dietary preference:{dietry_preference}, couisine preference: {couisine_preference}, flavor preference: {flavor_preference}, allergies: {allergies_if_any}")
            else:
                generate_recipe(f"Create a recipe from the edible items from the list:{detected_objects}")
    if prompt := st.chat_input("What's the receipe you want?"):
            generate_recipe(prompt)
    
    if len(st.session_state.missing_items) != 0:
        st.button("Add Missing Items to Cart", on_click= lambda: st.session_state.update(add_missing_clicked=True))
        if (st.session_state.add_missing_clicked):
            st.session_state.cart_list.extend(st.session_state.missing_items) 
            st.session_state.cart_list = list(set(item.lower().strip() for item in st.session_state.cart_list)) # remove duplicates
            cart_df = pd.DataFrame(st.session_state.cart_list, columns=['Items in Cart']) 
            cart_table.table(data=cart_df)
            if not st.session_state.add_recommended_clicked:
                recommended_items = generate_recommend_items(st.session_state.cart_list)
            st.button("Add Recommended Items to Cart", on_click= lambda: st.session_state.update(add_recommended_clicked=True))
            if st.session_state.add_recommended_clicked:
                st.session_state.cart_list.extend(st.session_state.recommended_items) 
                st.session_state.cart_list = list(set(item.lower().strip() for item in st.session_state.cart_list)) # remove duplicates
                cart_df = pd.DataFrame(st.session_state.cart_list, columns=['Items in Cart']) 
                cart_table.table(data=cart_df)
                
    
# hide_st_style = """
#             <style>
#             #MainMenu {visibility: hidden;}
#             footer {visibility: hidden;}
#             header {visibility: hidden;}
#             </style>
#             """
# st.markdown(hide_st_style, unsafe_allow_html=True)        


if __name__ == "__main__":
    
    # cart_list = ['milk', 'jaggery', 'apples', 'oats','rice', 'chicken', 'almonds', 'sunflower oil']
    # cart_list = ['white balsamic vinegar', 'salt', 'black pepper', 'chicken breasts', 'flour', 'butter', 'Irish whiskey', 'olive oil','chives', 'chicken stock', 'heavy cream']
    main_content = st.empty() 
    file_uploader_placeholder = st.empty()
    cart_table = st.sidebar.empty()
    uploaded_file = file_uploader_placeholder.file_uploader("Choose a Image from your regrigerator", type=["jpg", "jpeg", "png"])
    
    st.session_state.cart_list = ['white balsamic vinegar', 'salt', 'black pepper', 'chicken breasts', 'flour', 'butter', 'Irish whiskey', 'olive oil','chives', 'chicken stock', 'heavy cream']
    
    if st.session_state.submit_clicked:
        pass
    else:
        cart_df = pd.DataFrame(st.session_state.cart_list, columns=['Items in Cart'])
        cart_table = st.sidebar.table(data=cart_df)
               
    st.sidebar.button("Proceed for checkout", on_click= lambda: st.session_state.update(check_out_clicked=True))
    if st.session_state.check_out_clicked:
        insert_detail(st.session_state.cust_id,  st.session_state.order_id, st.session_state.cart_list)
        st.session_state.cart_list = []  
        st.session_state.messages = []
        cart_df = pd.DataFrame(st.session_state.cart_list, columns=['Items in Cart']) 
        cart_table.table(data=cart_df)  
        file_uploader_placeholder.empty()
        timeslots=["Morning 7 to 9 AM", "Morning 9 to 11:30 AM", "Afternoon 12 to 3 AM", "Evening 3 PM to 6 PM", "Evening 6 PM to 9 PM"]
        st.session_state.delivery_date = st.sidebar.date_input("Select Delivery Date", datetime.now().date())
        st.session_state.selected_time = st.sidebar.selectbox("select preferred delivery time: ",timeslots )
        st.sidebar.button("Submit", on_click= lambda: st.session_state.update(submit_clicked=True))
        if st.session_state.submit_clicked:
            main_content = st.empty()
            main_content.subheader(f"Thank you! Your Order will be delivered On {st.session_state.delivery_date} by {st.session_state.selected_time}.") 
            st.write(f"Order ID {st.session_state.order_id}") 
        # st.session_state.delivery_date =  st.sidebar.date_input("Select Delivery Date", datetime.now().date())
        # if st.session_state.delivery_date:
        #     main_content.subheader(f"Thank you! Your items will be delivered by {st.session_state.delivery_date}.")
        # else:
        #     main_content.subheader(f"Thank you! Your items will be delivered soon.") 
      
    
    if st.session_state.cart_list:
        main_content = main(st.session_state.cart_list) 
